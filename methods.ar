reactive methods
{
  input:
    i : Ta;
    a : <reapply, reapply(l1: Atom, l2: Atom)>?;

  output:
    v1 : Ta;
    v2 : Ta;
    d1 : Ta;
    d2 : Ta;

  state:
    v1 : Ta = :g(d1);
    v2 : Ta = :l(d2);

  rules:
    v1 = if   a? and a == :reapply                        then :g(#d1)
         elif a? and a :: <reapply(l1: Atom, l2: Atom)>   then {a.l1}(#d1)
         elif i == :a3 and i != #i                        then :p(d1)
                                                          else v1
         : i, a;

    v2 = if   a? and a == :reapply                        then :l(#d2)
         elif a? and a :: <reapply(l1: Atom, l2: Atom)>   then {a.l2}(#d2)
         elif i == :a4 and i != #i                        then :q(d2)
                                                          else v2
         : i, a;

    d1 = :f(i);
    d2 = :h(v1);
}


Any methods.my_meth(<v1> p) = v1;

Any methods.my_meth(<v2> p) = v2;

Any methods.my_meth(<d1> p) = d1;

Any methods.my_meth(<d2> p) = d2;


(Any, Any) methods.my_other_meth(<v1, v2, d1, d2> p1, <v1, v2, d1, d2> p2) = (my_meth(p1), my_meth(p2));


Any* method_test_data_1a = (
  (0, :a0, :f(:a0), :g(:f(:a0)), :h(:g(:f(:a0))), :l(:h(:g(:f(:a0))))),
  (0, :a1, :f(:a1), :g(:f(:a0)), :h(:g(:f(:a0))), :l(:h(:g(:f(:a0))))),
  (0, :a2, :f(:a2), :g(:f(:a0)), :h(:g(:f(:a0))), :l(:h(:g(:f(:a0))))),
  (0, :a3, :f(:a3), :p(:f(:a3)), :h(:p(:f(:a3))), :l(:h(:g(:f(:a0))))),
  (0, :a4, :f(:a4), :p(:f(:a3)), :h(:p(:f(:a3))), :q(:h(:p(:f(:a3))))),
  (0, :a5, :f(:a5), :p(:f(:a3)), :h(:p(:f(:a3))), :q(:h(:p(:f(:a3))))),
  (1, :a5, :f(:a5), :g(:f(:a5)), :h(:g(:f(:a5))), :l(:h(:p(:f(:a3))))),
  (0, :a6, :f(:a6), :g(:f(:a5)), :h(:g(:f(:a5))), :l(:h(:p(:f(:a3))))),
  (1, :a6, :f(:a6), :g(:f(:a6)), :h(:g(:f(:a6))), :l(:h(:g(:f(:a5))))),
  (0, :a7, :f(:a7), :g(:f(:a6)), :h(:g(:f(:a6))), :l(:h(:g(:f(:a5))))),
  (2, :a7, :f(:a7), :s(:f(:a7)), :h(:s(:f(:a7))), :t(:h(:g(:f(:a6))))),
  (0, :a8, :f(:a8), :s(:f(:a7)), :h(:s(:f(:a7))), :t(:h(:g(:f(:a6))))),
  (0, :a3, :f(:a3), :p(:f(:a3)), :h(:p(:f(:a3))), :t(:h(:g(:f(:a6))))),
  (2, :a3, :f(:a3), :s(:f(:a3)), :h(:s(:f(:a3))), :t(:h(:p(:f(:a3)))))
);


Any* method_test_data_1b = (
  (0, :a0, :f(:a0), :g(:f(:a0)), :h(:g(:f(:a0))), :l(:h(:g(:f(:a0))))),
  (0, :a1, :f(:a1), :g(:f(:a0)), :h(:g(:f(:a0))), :l(:h(:g(:f(:a0))))),
  (0, :a2, :f(:a2), :g(:f(:a0)), :h(:g(:f(:a0))), :l(:h(:g(:f(:a0))))),
  (0, :a3, :f(:a3), :p(:f(:a3)), :h(:p(:f(:a3))), :l(:h(:g(:f(:a0))))),
  (0, :a4, :f(:a4), :p(:f(:a3)), :h(:p(:f(:a3))), :q(:h(:p(:f(:a3))))),
  // (0, :a5, :f(:a5), :p(:f(:a3)), :h(:p(:f(:a3))), :q(:h(:p(:f(:a3))))),
  (1, :a5, :f(:a5), :g(:f(:a5)), :h(:g(:f(:a5))), :l(:h(:p(:f(:a3))))),
  // (0, :a6, :f(:a6), :g(:f(:a5)), :h(:g(:f(:a5))), :l(:h(:p(:f(:a3))))),
  (1, :a6, :f(:a6), :g(:f(:a6)), :h(:g(:f(:a6))), :l(:h(:g(:f(:a5))))),
  // (0, :a7, :f(:a7), :g(:f(:a6)), :h(:g(:f(:a6))), :l(:h(:g(:f(:a5))))),
  (2, :a7, :f(:a7), :s(:f(:a7)), :h(:s(:f(:a7))), :t(:h(:g(:f(:a6))))),
  (0, :a8, :f(:a8), :s(:f(:a7)), :h(:s(:f(:a7))), :t(:h(:g(:f(:a6))))),
  // (0, :a3, :f(:a3), :p(:f(:a3)), :h(:p(:f(:a3))), :t(:h(:g(:f(:a6))))),
  (2, :a3, :f(:a3), :s(:f(:a3)), :h(:s(:f(:a3))), :t(:h(:p(:f(:a3)))))
);


Any* method_test_data_2a = (
  (0, :a0, :f(:a0), :g(:f(:a0)), :h(:g(:f(:a0))), :l(:h(:g(:f(:a0))))),
  (2, :a0, :f(:a0), :s(:f(:a0)), :h(:s(:f(:a0))), :t(:h(:g(:f(:a0))))),
  (0, :a1, :f(:a1), :s(:f(:a0)), :h(:s(:f(:a0))), :t(:h(:g(:f(:a0))))),
  (0, :a3, :f(:a3), :p(:f(:a3)), :h(:p(:f(:a3))), :t(:h(:g(:f(:a0))))),
  (1, :a3, :f(:a3), :g(:f(:a3)), :h(:g(:f(:a3))), :l(:h(:p(:f(:a3))))),
  (0, :a4, :f(:a4), :g(:f(:a3)), :h(:g(:f(:a3))), :q(:h(:g(:f(:a3))))),
  (2, :a4, :f(:a4), :s(:f(:a4)), :h(:s(:f(:a4))), :t(:h(:g(:f(:a3)))))
);


Any* method_test_data_2b = (
  // (0, :a0, :f(:a0), :g(:f(:a0)), :h(:g(:f(:a0))), :l(:h(:g(:f(:a0))))),
  (2, :a0, :f(:a0), :s(:f(:a0)), :h(:s(:f(:a0))), :t(:h(:g(:f(:a0))))),
  (0, :a1, :f(:a1), :s(:f(:a0)), :h(:s(:f(:a0))), :t(:h(:g(:f(:a0))))),
  // (0, :a3, :f(:a3), :p(:f(:a3)), :h(:p(:f(:a3))), :t(:h(:g(:f(:a0))))),
  (1, :a3, :f(:a3), :g(:f(:a3)), :h(:g(:f(:a3))), :l(:h(:p(:f(:a3))))),
  // (0, :a4, :f(:a4), :g(:f(:a3)), :h(:g(:f(:a3))), :q(:h(:g(:f(:a3))))),
  (2, :a4, :f(:a4), :s(:f(:a4)), :h(:s(:f(:a4))), :t(:h(:g(:f(:a3)))))
);


Bool RunBasicMethodTests(Any* test_data)
{
  auto t : methods;

  for a, i, ed1, ev1, ed2, ev2 @ j <- test_data:
    // print "-----------------------------------------------------";
    // print (a, i);
    // print (t.v1, t.v2, t.d1, t.d2);

    auto t.i = i;
    auto apply t;
    // print (t.v1, t.v2, t.d1, t.d2);

    if a == 1:
      auto t.a = :reapply;
    elif a == 2:
      auto t.a = reapply(l1: :s, l2: :t);
    ;

    auto apply t;
    // print (t.v1, t.v2, t.d1, t.d2);

    if not {t.v1 == ev1 and t.v2 == ev2 and t.d1 == ed1 and t.d2 == ed2}:
      Print("Error\n");
      print (ev1, ev2, ed1, ed2);
      print t.v1;
      print t.v2;
      print t.d1;
      print t.d2;
      return false;
    // else
    //   Print("OK\n");
    ;

    id_combs = (
      (:v1, :v2), (:d1, :d2), (:v1, :d2), (:d1, :v2),
      (:v2, :v1), (:d2, :d1), (:v2, :d1), (:d2, :v1),
      (:v1, :v1), (:d1, :d1), (:v1, :d1), (:d1, :v1),
      (:v2, :v2), (:d2, :d2), (:v2, :d2), (:d2, :v2)
    );

    exp_res = (
      (t.v1, t.v2), (t.d1, t.d2), (t.v1, t.d2), (t.d1, t.v2),
      (t.v2, t.v1), (t.d2, t.d1), (t.v2, t.d1), (t.d2, t.v1),
      (t.v1, t.v1), (t.d1, t.d1), (t.v1, t.d1), (t.d1, t.v1),
      (t.v2, t.v2), (t.d2, t.d2), (t.v2, t.d2), (t.d2, t.v2)
    );

    act_res = (t.my_other_meth(id1, id2) : id1, id2 <- id_combs);

    if act_res != exp_res:
      Print("ERROR (METHODS):\n");
      print exp_res;
      print act_res;
      return false;
    ;
  ;

  return true;
}


Bool RunAllMethodTests()
{
  ok = RunBasicMethodTests(method_test_data_1a);
  return false if not ok;
  ok = RunBasicMethodTests(method_test_data_1b);
  return false if not ok;
  ok = RunBasicMethodTests(method_test_data_2a);
  return false if not ok;
  ok = RunBasicMethodTests(method_test_data_2b);
  return ok;
}
