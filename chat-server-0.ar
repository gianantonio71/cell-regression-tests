auto chat_server_0_core_state
{
  output
    [UserId -> String]  user_names,
    [String -> UserId]  user_ids,
    [UserId -> [RoomId]] user_rooms,
    [RoomId -> [+UserId]] room_users;

  state
    [UserId -> String]  user_names  = [:],
    [String -> UserId]  user_ids    = [:],
    [UserId -> RoomId]  user_rooms  = [:],
    [RoomId -> [+UserId]] room_users  = [:];
}


chat_server_0_core_state.do(Login msg)
{
  user = msg.user;
  name = msg.name;
  user_names  := update(user_names, user, name);
  user_ids    := update(user_ids, name, user);
  user_rooms  := update(user_rooms, user, []);
}


chat_server_0_core_state.do(Logout msg)
{
  user = msg.user;
  name = user_names[user];
  rooms = user_rooms[user];

  user_ids    := remove_key(user_ids, name);
  user_names  := remove_key(user_names, user);
  user_rooms  := remove_key(user_rooms, user);

  unaffected_rooms = remove_keys(room_users, rooms);
  affected_rooms = [r -> users_left : r <- rooms, users_left = room_users[r] - [user], users_left != []];
  room_users := unaffected_rooms & affected_rooms;
}


chat_server_0_core_state.do(JoinRoom msg)
{
  user = msg.user;
  room = msg.room;

  new_rooms = user_rooms[user] & [room];
  user_rooms := update(user_rooms, user, new_rooms);

  new_users = lookup(room_users, room, []) & [user];
  room_users := update(room_users, room, new_users);
}


chat_server_0_core_state.do(LeaveRoom msg)
{
  user = msg.user;
  room = msg.room;

  new_rooms = user_rooms[user] - [room];
  user_rooms := update(user_rooms, user, new_rooms);

  users_left = room_users[room] - [user];
  room_users := if users_left != []
    then update(room_users, room, users_left)
    else remove_key(room_users, room);
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

auto chat_server_0
{
  output [Nat -> (Nat, String)] data_to_send;

  state [Nat -> Byte*] pending_inputs = [:];
  state Nat msg_counter = 0;
  state [Nat -> (Nat, String)] data_to_send = [:];

  core_state = chat_server_0_core_state();

  //## DEBUGGING CODE
  output Any pending_inputs;
  output Any msg_counter;

  output Any user_names;
  output Any user_ids;
  output Any user_rooms;
  output Any room_users;

  user_names = core_state.user_names;
  user_ids = core_state.user_ids;
  user_rooms = core_state.user_rooms;
  room_users = core_state.room_users;
}


chat_server_0.do(Connect msg)
{
  pending_inputs := update(pending_inputs, msg.channel, ());
}


chat_server_0.do(Disconnect msg)
{
  channel = msg.channel;
  pending_inputs := remove_key(pending_inputs, channel);
  is_logged_in = has_key(core_state.user_names, channel);
  core_state.do(logout(user: channel)) if is_logged_in;
}


chat_server_0.do(Received msg)
{
  channel = msg.channel;
  new_data = msg.data;
  pend_data = pending_inputs[channel];

  if new_data == ascii_newline:
    pending_inputs := update(pending_inputs, channel, ());
    maybe_msg = try_parse_msg(pending_inputs[channel], channel);
    if maybe_msg != nil:
      self.do(value(maybe_msg));
    else
      data_to_send := data_to_send & [msg_counter -> (channel, "ERROR syntax error")];
      msg_counter := msg_counter + 1;
    ;

  else
    pending_inputs := update(pending_inputs, channel, (pend_data | new_data));
  ;
}


chat_server_0.do(Sent msg)
{
  data_to_send := remove_key(data_to_send, msg.msg_id);
}

////////////////////////////////////////////////////////////////////////////////

chat_server_0.do(Login msg)
{
  user = msg.user;
  name = msg.name;

  already_logged_in = has_key(core_state.user_names, user);
  name_already_taken = has_key(core_state.user_ids, name);

  core_state.do(msg) if not {already_logged_in or name_already_taken};

  resp_msg = if already_logged_in    then "ERROR already logged in",
                name_already_taken   then "ERROR name already in use"
                                     else "OK";

  data_to_send := update(data_to_send, msg_counter, (user, resp_msg));
  msg_counter := msg_counter + 1;
}


chat_server_0.do(Logout msg)
{
  core_state.do(msg) if has_key(core_state.user_names, msg.user);
}


chat_server_0.do(JoinRoom msg)
{
  user = msg.user;

  is_logged_in = has_key(core_state.user_names, user);

  core_state.do(msg) if is_logged_in;

  resp_msg = if is_logged_in then "OK" else "ERROR not logged in";

  data_to_send := update(data_to_send, msg_counter, (user, resp_msg));
  msg_counter  := msg_counter + 1;
}


chat_server_0.do(LeaveRoom msg)
{
  user = msg.user;
  room = msg.room;

  is_logged_in = has_key(core_state.user_names, user);
  has_joined_room = is_logged_in and core_state.user_rooms[user](room);

  core_state.do(msg) if has_joined_room;

  resp_msg = if not is_logged_in    then "ERROR not logged in",
                not has_joined_room then "ERROR never joined room"
                                    else "OK";

  data_to_send := update(data_to_send, msg_counter, (user, resp_msg));
  msg_counter  := msg_counter + 1;
}


chat_server_0.do(SendMsgToUser msg)
{
  sender = msg.sender;
  receiver = msg.receiver;
  msg_text = msg.msg_text;

  is_logged_in = has_key(core_state.user_names, sender);
  target_exists = has_key(core_state.user_ids, receiver);

  resp_msg = if not is_logged_in  then "ERROR not logged in",
                not target_exists then "ERROR unknown user"
                                  else "OK";

  new_data_to_send = [msg_counter -> (sender, resp_msg)];
  msgs_sent = 1;

  if is_logged_in and target_exists:
    fwd_msg = "GOTUSERMSG " & core_state.user_names[sender] & " " & msg_text;
    new_data_to_send = new_data_to_send & [msg_counter + msgs_sent -> (core_state.user_ids[receiver], fwd_msg)];
    msgs_sent = msgs_sent + 1;
  ;

  data_to_send := data_to_send & new_data_to_send;
  msg_counter := msg_counter + msgs_sent;
}


chat_server_0.do(SendMsgToRoom msg)
{
  sender = msg.sender;
  target = msg.target;
  msg_text = msg.msg_text;

  is_logged_in = has_key(core_state.user_names, sender);
  has_joined_room = is_logged_in and core_state.user_rooms[sender](target);

  resp_msg = if not is_logged_in      then "ERROR not logged in",
                not has_joined_room   then "ERROR never joined room"
                                      else "OK";

  new_data_to_send = [msg_counter -> (sender, resp_msg)];
  msgs_sent = 1;

  if is_logged_in:
    fwd_msg = "GOTROOMMSG " & core_state.user_names[sender] & " #" & target & " " & msg_text;
    receivers = rand_sort(lookup(core_state.room_users, target, []));
    new_data_to_send = new_data_to_send & merge(([msg_counter + i + 1 -> (r, fwd_msg)] : r @ i <- receivers));
    msgs_sent = msgs_sent + length(receivers);
  ;

  data_to_send := data_to_send & new_data_to_send;
  msg_counter := msg_counter + msgs_sent;
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

Bool RunAllChatServer0Tests()
{
  auto chat_server_0 cs;

  update cs;

  sorted_users = rand_sort(set((u : u, unused_var <- chat_server_test_data_1)));
  conn_ids = merge(([u -> i] : u @ i <- sorted_users));

  for i < size(conn_ids):
    cs.do(connect(i));
    update cs;
    // print cs;
  ;

  for u, s <- chat_server_test_data_1:
    cid = conn_ids[u];
    for ch <- raw_str(s):
      cs.do(received(cid, ch));
      update cs;
    ;
    cs.do(received(cid, ascii_newline));
    update cs;
    // print s;
    // print cs;
  ;

  for i < size(conn_ids):
    cs.do(disconnect(i));
    update cs;
    // print cs;
  ;

  if cs.data_to_send != chat_server_exp_res_1:
    Print("ERROR (1)\n");
    print cs.data_to_send;
    print chat_server_exp_res_1;
    return false;
  ;

  for i < cs.msg_counter:
    cs.do(sent(i));
    update cs;
    // print cs;
    if size(cs.data_to_send) != cs.msg_counter - i - 1:
      Print("ERROR (2)\n");
      print i;
      print cs.data_to_send;
      return false;
    ;
  ;

  assert cs.data_to_send == [:];
  return true;
}
