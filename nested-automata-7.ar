type NestedAuto7Mgs = reset, incr_counter(Nat);


reactive nested_automata_7_some_counter
{
  input:
    an_input : Ta;
    msg      : NestedAuto7Mgs?;

  output:
    a_counter : Nat;

  state:
    flow_counter : Nat = 0;
    msg_counter  : Nat = 0;

  rules:
    flow_counter = flow_counter + 1 if an_input == :a0 or an_input == :a3 or an_input == :a5;
    msg_counter = if msg == :reset then 0 else msg_counter + _obj_(msg);
    a_counter = flow_counter + msg_counter;
}


reactive nested_automata_7
{
  input:
    my_input  : Ta;
    increment : Nat?;

  output:
    my_counter     : Nat;
    nested_counter : Nat;

  state:
    my_counter : Nat = 0;

  rules:
    msg := :incr_counter(increment);
    na = nested_automata_7_some_counter(an_input=my_input, msg=msg);
    my_counter = _add_(my_counter, 1) if my_input == :a1 or my_input == :a4;
    nested_counter = na.a_counter;
}


(Ta, Maybe[Nat], Nat, Nat)* nested_automata_7_test_data = (
  (:a0,       nil,    0,    0),
  (:a1,       nil,    1,    0),
  (:a2,       nil,    1,    0),
  (:a3,       nil,    1,    1),
  (:a4, :just(10),    2,   11),
  (:a5,       nil,    2,   12),
  (:a6,       nil,    2,   12),
  (:a0,:just(100),    2,  113),
  (:a1,       nil,    3,  113),
  (:a2,       nil,    3,  113),
  (:a3,       nil,    3,  114),
  (:a4,       nil,    4,  114),
  (:a5,       nil,    4,  115),
  (:a0,       nil,    4,  115)
);


Bool RunAllNestedAutomata7Tests()
{
  auto ta : nested_automata_7;

  for input, incr, ec, enc<- nested_automata_7_test_data:
    auto ta.my_input = input;
    if incr != nil:
      auto ta.increment = match (incr) just(n?) = n;
    ;
    auto apply ta;

    if ta.my_counter != ec or ta.nested_counter != enc:
      Print("ERROR\n");
      print (input, incr, ec, enc);
      print ta.my_counter;
      print ta.nested_counter;
      return false;
    // else
    //   Print("OK\n");
    ;
  ;

  return true;
}
