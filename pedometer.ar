Float (-_)(Float x) = _fneg_(x);

Float (_+_)(Float x1, Float x2) = _fadd_(x1, x2);
Float (_-_)(Float x1, Float x2) = _fsub_(x1, x2);
Float (_*_)(Float x1, Float x2) = _fmult_(x1, x2);
Float (_/_)(Float x1, Float x2) = _fdiv_(x1, x2);

Float sqrt(Float x) = _fsqrt_(x);

////////////////////////////////////////////////////////////////////////////////

type PointF = point(x: Float, y: Float);

PointF point(Float x, Float y) = point(x: x, y: y);

Float point_to_point_distance(PointF p1, PointF p2) {
  dx = p1.x - p2.x;
  dy = p1.y - p2.y;
  return sqrt(dx * dx + dy * dy);
}

////////////////////////////////////////////////////////////////////////////////

reactive pedometer_0 {
  input:
    has_moved     : Bool;
    position      : PointF;
    unused_input  : Any;

  output:
    position_copy : PointF;
    track         : PointF*;
    distance      : Float;

  state:
    position_copy     : PointF   = position;
    track             : PointF*  = (position);
    distance          : Float   = 0.0;
    unused_state_var  : Any     = :f((:a, :b, :c));

  rules:
    unused_param = (:a, :b);

    position_copy = position if has_moved;
    track = (track | position) if has_moved;
    distance = distance + point_to_point_distance(rev_at(track, 1), rev_at(track, 0)) if has_moved and |track| > 1;
    unused_rule = reverse(track);
}

////////////////////////////////////////////////////////////////////////////////

reactive pedometer {
  input:
    position : PointF;

  output:
    track    : PointF+;
    distance : Float;

  state:
    track    : PointF+ = (position);
    distance : Float   = 0.0;

  rules:
    track = (track | position) : position;
    distance = distance + point_to_point_distance(position, @position) : position;
}

////////////////////////////////////////////////////////////////////////////////

(Float, Float)* route = (
  ( 0.0,   0.0),
  ( 5.2,  -0.3),
  ( 9.1,   1.1),
  (13.7,   0.9),
  (16.1,   2.8),
  (17.4,   6.3)
);


Float* expected_distances {
  ps = (point(x, y) : x, y <- route);
  ds = (0.0);
  for i = 1..|route|:
    ds = (ds | ds(i-1) + point_to_point_distance(ps(i-1), ps(i)));
  ;
  return ds;
}


Bool RunBasicPedometerTest() {
  auto p  : pedometer;
  auto p0 : pedometer_0;

  exp_ds = expected_distances;

  exp_track = (point(x, y) : x, y <- route);

  for x, y @ i <- route:
    pos = point(x, y);

    auto p.position = pos;
    auto apply p done;
    assert done;

    if p.distance != exp_ds(i):
      Print("Pedometer - Distance error!");
      return false;
    ;

    if p.track != subseq(exp_track, 0, i+1):
      Print("Pedometer - Track error!");
      return false;
    ;

    auto p0.position = point(x, y);
    auto p0.has_moved = true;
    auto p0.unused_input = :g((0, 1, 2));
    auto apply p0 done;
    assert done;

    auto p0.has_moved = false;
    auto apply p0 done;
    assert done;

    if p0.distance != exp_ds(i):
      Print("Pedometer (Old) - Distance error!");
      return false;
    ;

    if p0.track != subseq(exp_track, 0, i+1):
      Print("Pedometer (Old) - Track error!");
      return false;
    ;
  ;

  return true;
}


Bool RunAllPedometerTests() {
  res = RunBasicPedometerTest();
  return res;
}
