Float (-_)(Float x) = _fneg_(x);

Float (_+_)(Float x1, Float x2) = _fadd_(x1, x2);
Float (_-_)(Float x1, Float x2) = _fsub_(x1, x2);
Float (_*_)(Float x1, Float x2) = _fmult_(x1, x2);
Float (_/_)(Float x1, Float x2) = _fdiv_(x1, x2);

Float sqrt(Float x) = _fsqrt_(x);

////////////////////////////////////////////////////////////////////////////////

type Point = point(x: Float, y: Float);

Point point(Float x, Float y) = point(x: x, y: y);

Float distance(Point p1, Point p2)
{
  dx = p1.x - p2.x;
  dy = p1.y - p2.y;
  return sqrt(dx * dx + dy * dy);
}

////////////////////////////////////////////////////////////////////////////////

cell pedometer_0
{
  input:
    has_moved     : Bool;
    position      : Point;
    unused_input  : Any;

  output:
    position_copy : Point;
    track         : Point*;
    distance      : Float;

  state:
    position_copy     : Point   = position;
    track             : Point*  = (position);
    distance          : Float   = 0.0;
    unused_state_var  : Any     = :f((:a, :b, :c));

  rules:
    unused_param = (:a, :b);

    position_copy = position if has_moved;
    track = (track || position) if has_moved;
    distance = distance + distance(rev_at(track, 1), rev_at(track, 0)) if has_moved and length(track) > 1;
    unused_rule = reverse(track);
}

////////////////////////////////////////////////////////////////////////////////

cell pedometer
{
  input:
    position : Point;

  output:
    track    : Point*;
    distance : Float;

  state:
    track    : Point* = (position);
    distance : Float  = 0.0;

  rules:
    track = (track || position) : position;
    distance = distance + distance(position, #position) : position;
}

////////////////////////////////////////////////////////////////////////////////

(Float, Float)* route = (
  ( 0.0,   0.0),
  ( 5.2,  -0.3),
  ( 9.1,   1.1),
  (13.7,   0.9),
  (16.1,   2.8),
  (17.4,   6.3)
);


Float* expected_distances
{
  ps = (point(x, y) | x, y <- route);
  ds = (0.0);
  for i = 1..length(route):
    ds = (ds || ds(i-1) + distance(ps(i-1), ps(i)));
  ;
  return ds;
}


Bool RunBasicPedometerTest()
{
  auto p  : pedometer;
  auto p0 : pedometer_0;

  exp_ds = expected_distances;

  exp_track = (point(x, y) | x, y <- route);

  for x, y @ i <- route:
    pos = point(x, y);

    auto p.position = pos;
    auto apply p;

    if p.distance != exp_ds(i):
      Print("Pedometer - Distance error!");
      return false;
    ;

    if p.track != subseq(exp_track, 0, i+1):
      Print("Pedometer - Track error!");
      return false;
    ;

    auto p0.position = point(x, y);
    auto p0.has_moved = true;
    auto p0.unused_input = :g((0, 1, 2));
    auto apply p0;

    auto p0.has_moved = false;
    auto apply p0;

    if p0.distance != exp_ds(i):
      Print("Pedometer (Old) - Distance error!");
      return false;
    ;

    if p0.track != subseq(exp_track, 0, i+1):
      Print("Pedometer (Old) - Track error!");
      return false;
    ;
  ;

  return true;
}


Bool RunAllPedometerTests()
{
  res = RunBasicPedometerTest();
  return res;
}
