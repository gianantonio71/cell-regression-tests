reactive filtered_history
{
  input:
    input : Ta?;

  output:
    history : Ta+;
    input_filtered : Ta?;

  state:
    history : Ta+ = ();

  rules:
    history = (history | input) : input;
    input_filtered := input if input != :a2;
}


reactive nested_automata_1
{
  input:
    i : Ta?;

  output:
    h   : Ta+;
    hs  : Nat;
    fi  : Ta?;
    fib : Ta+?;

  rules:
    ha = filtered_history(input = i);
    h = ha.history;
    fi := ha.input_filtered;

    hs = _len_(h);
    fib := (fi);
}


(Ta, Bool)* nested_automata_1_test_data = (
  (:a0, true),
  (:a1, true),
  (:a2, false),
  (:a3, true),
  (:a4, true),
  (:a0, true),
  (:a1, true),
  (:a2, false),
  (:a3, true),
  (:a4, true)
);


Bool RunAllNestedAutomata1Tests()
{
  auto ta : nested_automata_1;

  auto apply ta;

  eh = ();
  ehs = 0;

  for i, s <- nested_automata_1_test_data:
    eh = (eh | i);
    ehs = _add_(ehs, 1);
    auto ta.i = i;
    auto apply ta;
    if ta.h != eh or ta.hs != ehs:
      Print("ERROR!\n");
      print ta.h;
      print ta.hs;
      print ta.fi;
      print ta.fib;
      print (eh, ehs);
      return false;
    ;
    if ta.fi? != s or ta.fib? != s:
      Print("DISCRETE SET/UNSET ERROR!\n");
      print ta.h;
      print ta.hs;
      print ta.fi;
      print ta.fib;
      print s;
      return false;
    ;
    if s and {ta.fi != i or ta.fib != (i)}:
      Print("DISCRETE VALUE ERROR!\n");
      print ta.h;
      print ta.hs;
      print ta.fi;
      print ta.fib;
      print s;
      return false;
    ;
    // Print("OK\n");
    // print ta;
  ;

  return true;
}
