type Reset  = reset;
type Incr   = increment;
type Decr   = decrement;
type Acc    = accumulate(Int);



auto polymorphic_methods_some_counter
{
  input Ta an_input;
  output Int a_counter;
  state Int a_counter = 0;

  a_counter = _add_(a_counter, 2) if an_input == :a1 or an_input == :a3 or an_input == :a5;
}


polymorphic_methods_some_counter.run(Reset msg)
{
  a_counter := 0;
}

polymorphic_methods_some_counter.run(Incr msg)
{
  a_counter := _add_(a_counter, 1);
}

polymorphic_methods_some_counter.run(Decr msg)
{
  a_counter := _sub_(a_counter, 1);
}

polymorphic_methods_some_counter.run(Acc msg)
{
  a_counter := _add_(a_counter, _obj_(msg));
}

polymorphic_methods_some_counter.reset()
{
  a_counter := 0;
}

polymorphic_methods_some_counter.set_counter(Nat value)
{
  a_counter := value;
}


auto polymorphic_methods_1
{
  input Ta my_input;
  output Nat my_counter, Nat nested_counter;
  state Nat my_counter = 0;

  na = polymorphic_methods_some_counter(an_input=my_input);

  my_counter = _add_(my_counter, 1) if my_input == :a1 or my_input == :a4;

  msg = match (my_input)
    a0  = :just(:accumulate(100)),
    a2  = :just(:decrement),
    a4  = :just(:increment),
    a6  = :just(:reset),
    _   = nil;

  na.run(value(msg)) if msg != nil;

  nested_counter = na.a_counter;
}


auto polymorphic_methods_2
{
  input Ta my_input;
  output Nat my_counter, Nat nested_counter;
  state Nat my_counter = 0;

  na = polymorphic_methods_some_counter(an_input=my_input);

  my_counter = _add_(my_counter, 1) if my_input == :a1 or my_input == :a4;

  msg := match (my_input)
      a0  = :accumulate(100),
      a2  = :decrement,
      a4  = :increment,
      a6  = :reset
    if my_input :: <a0, a2, a4, a6> : my_input;

  na.run(msg);

  nested_counter = na.a_counter;
}


(Ta, Int, Int)* polymorphic_methods_test_data_1 = (
  (:a0,   0,     0),
  (:a1,   1,     2),
  (:a2,   1,     1),
  (:a3,   1,     3),
  (:a4,   2,     4),
  (:a5,   2,     6),
  (:a6,   2,     0),
  (:a7,   2,     0),
  (:a0,   2,   100),
  (:a1,   3,   102),
  (:a2,   3,   101),
  (:a3,   3,   103),
  (:a4,   4,   104),
  (:a5,   4,   106),
  (:a6,   4,     0)
);


(Ta, Int, Int)* polymorphic_methods_test_data_2 = (
  (:a0,   0,     0),
  (:a2,   0,     0),
  (:a4,   1,     0),
  (:a6,   1,     0),
  (:a7,   1,     0),
  (:a0,   1,   100),
  (:a2,   1,   100),
  (:a4,   2,   100),
  (:a6,   2,   100)
);


(Ta, Int, Int)* polymorphic_methods_test_data_3 = (
  (:a0,   0,         0),
  (:a2,   0,  _neg_(1)),
  (:a4,   1,         0),
  (:a6,   1,         0),
  (:a7,   1,         0),
  (:a0,   1,       100),
  (:a2,   1,        99),
  (:a4,   2,       100),
  (:a6,   2,         0)
);


Bool RunPolymorphicMethodsTestA((Ta, Int, Int)* test_data)
{
  auto polymorphic_methods_1 ta;

  for input, ec, enc<- test_data:
    ta.my_input = input;
    update ta;

    if ta.my_counter != ec or ta.nested_counter != enc:
      Print("ERROR\n");
      print (input, ec, enc);
      print ta;
      return false;
    // else
    //   Print("OK\n");
    ;
  ;
  return true;
}


Bool RunPolymorphicMethodsTestB((Ta, Int, Int)* test_data)
{
  auto polymorphic_methods_2 ta;

  for input, ec, enc<- test_data:
    ta.my_input = input;
    update ta;

    if ta.my_counter != ec or ta.nested_counter != enc:
      Print("ERROR\n");
      print (input, ec, enc);
      print ta;
      return false;
    // else
    //   Print("OK\n");
    ;
  ;
  return true;
}


Bool RunAllPolymorphicMethodsTests()
{
  ok = RunPolymorphicMethodsTestA(polymorphic_methods_test_data_1);
  return false if not ok;
  ok = RunPolymorphicMethodsTestA(polymorphic_methods_test_data_2);
  return false if not ok;
  ok = RunPolymorphicMethodsTestB(polymorphic_methods_test_data_1);
  return false if not ok;
  ok = RunPolymorphicMethodsTestB(polymorphic_methods_test_data_3);
  return ok;
}
