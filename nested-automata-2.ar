auto filtered_history_2
{
  input Ta to_skip;

  discrete input Ta input;

  output Ta+ history;

  discrete output Ta input_filtered;

  state Ta+ history = ();

  history = (history | input) : input;

  input_filtered := input if input != to_skip;
}


auto nested_automata_2
{
  discrete input Ta i;

  output Ta+ h, Nat hs;
  discrete output Ta fi, Ta+ fib;

  ha1 = filtered_history_2(to_skip = :a2, input = i);

  ha2 = filtered_history_2(to_skip = :a3, input = ha1.input_filtered);

  h = ha2.history;
  fi := ha2.input_filtered;

  hs = _len_(h);
  fib := (fi);
}


(Ta, Bool, Bool)* nested_automata_2_test_data = (
  (:a0, true,  true),
  (:a1, true,  true),
  (:a2, false, false),
  (:a3, true,  false),
  (:a4, true,  true),
  (:a0, true,  true),
  (:a1, true,  true),
  (:a2, false, false),
  (:a3, true,  false),
  (:a4, true,  true)
);


Bool RunAllNestedAutomata2Tests()
{
  auto nested_automata_2 ta;

  update ta;

  eh = ();
  ehs = 0;

  for i, s1, s2 <- nested_automata_2_test_data:
    eh = (eh | i) if i != :a2;
    ehs = _add_(ehs, 1) if i != :a2;
    ta.i = i;
    update ta;
    if ta.h != eh or ta.hs != ehs:
      Print("ERROR!\n");
      print ta;
      print (eh, ehs);
      return false;
    ;
    if ta.fi? != s2 or ta.fib? != s2:
      Print("DISCRETE SET/UNSET ERROR!\n");
      print ta;
      print s2;
      return false;
    ;
    if s2 and {ta.fi != i or ta.fib != (i)}:
      Print("DISCRETE VALUE ERROR!\n");
      print ta;
      print s2;
      return false;
    ;
    // Print("OK\n");
    // print ta;
  ;

  return true;
}
