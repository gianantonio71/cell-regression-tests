auto chat_server_1_core_state
{
  output
    [UserId -> String]  user_names,
    [String -> UserId]  user_ids,
    [UserId -> [RoomId]] user_rooms,
    [RoomId -> [+UserId]] room_users;

  state
    [UserId -> String]  user_names  = [:],
    [String -> UserId]  user_ids    = [:],
    [UserId -> RoomId]  user_rooms  = [:],
    [RoomId -> [+UserId]] room_users  = [:];
}

////////////////////////////////////////////////////////////////////////////////

Bool chat_server_1_core_state.is_logged_in(UserId user) = _has_key_(user_names, user);

Bool chat_server_1_core_state.user_exists(UserId user) = _has_key_(user_ids, user);

Bool chat_server_1_core_state.user_has_joined_room(UserId user, RoomId room)
{
  rooms_joined = _lookup_(user_rooms, user);
  return _in_(room, rooms_joined);
}


LoginCheck chat_server_1_core_state.login_check(UserId user, String name) =
  if self.is_logged_in(user)    then :already_logged_in,
     _has_key_(user_ids, name)  then :name_already_in_use
                                else :ok;


LoginCheck chat_server_1_core_state.logout_check(UserId user) =
  if self.is_logged_in(user) then :ok else :not_logged_in;


JoinRoomCheck chat_server_1_core_state.join_room_check(UserId user) =
  if self.is_logged_in(user) then :ok else :not_logged_in;


LeaveRoomCheck chat_server_1_core_state.leave_room_check(UserId user, RoomId room) =
  if not self.is_logged_in(user)                then :not_logged_in,
     not self.user_has_joined_room(user, room)  then :not_in_room
                                                else :ok;


SendMsgToUserCheck chat_server_1_core_state.action_check(SendMsgToUser msg) =
  if not self.is_logged_in(msg.sender)  then :not_logged_in,
     not self.user_exists(msg.receiver) then :unknown_receiver
                                        else :ok;


SendMsgToRoomCheck chat_server_1_core_state.action_check(SendMsgToRoom msg) =
  if not self.is_logged_in(msg.sender)                      then :not_logged_in,
     not self.user_has_joined_room(msg.sender, msg.target)  then :not_in_room
                                                            else :ok;


ActionCheck chat_server_1_core_state.action_check(ChatServerCoreAction action):
  login()   = self.login_check(action.user, action.name),
  logout()  = self.logout_check(action.user),
  join()    = self.join_room_check(action.user),
  leave()   = self.leave_room_check(action.user, action.room);

////////////////////////////////////////////////////////////////////////////////

chat_server_1_core_state.do(Login msg)
{
  user = msg.user;
  name = msg.name;
  user_names  := update(user_names, user, name);
  user_ids    := update(user_ids, name, user);
  user_rooms  := update(user_rooms, user, []);
}


chat_server_1_core_state.do(Logout msg)
{
  user = msg.user;
  name = user_names[user];
  rooms = user_rooms[user];

  user_ids    := remove_key(user_ids, name);
  user_names  := remove_key(user_names, user);
  user_rooms  := remove_key(user_rooms, user);

  unaffected_rooms = remove_keys(room_users, rooms);
  affected_rooms = [r -> users_left : r <- rooms, users_left = room_users[r] - [user], users_left != []];
  room_users := unaffected_rooms & affected_rooms;
}


chat_server_1_core_state.do(JoinRoom msg)
{
  user = msg.user;
  room = msg.room;

  new_rooms = user_rooms[user] & [room];
  user_rooms := update(user_rooms, user, new_rooms);

  new_users = lookup(room_users, room, []) & [user];
  room_users := update(room_users, room, new_users);
}


chat_server_1_core_state.do(LeaveRoom msg)
{
  user = msg.user;
  room = msg.room;

  new_rooms = user_rooms[user] - [room];
  user_rooms := update(user_rooms, user, new_rooms);

  users_left = room_users[room] - [user];
  room_users := if users_left != []
    then update(room_users, room, users_left)
    else remove_key(room_users, room);
}

chat_server_1_core_state.safe_do(ChatServerCoreAction action)
{
  check_res = self.action_check(action);
  self.do(action) if check_res == :ok;
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

auto safe_chat_server_1_core_state
{
  discrete input ChatServerCoreAction action;

  // discrete output ActionCheck check_res;

  core_state = chat_server_1_core_state();

  // check_res := core_state.action_check(action);
  // core_state.do(action) if check_res == :ok;

  core_state.safe_do(action);

  output Any user_names;
  output Any user_ids;
  output Any user_rooms;
  output Any room_users;

  user_names = core_state.user_names;
  user_ids = core_state.user_ids;
  user_rooms = core_state.user_rooms;
  room_users = core_state.room_users;
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

auto chat_server_1
{
  output [Nat -> (Nat, String)] data_to_send;

  state [Nat -> Byte*] pending_inputs = [:];
  state Nat msg_counter = 0;
  state [Nat -> (Nat, String)] data_to_send = [:];

  core_state = chat_server_1_core_state();

  //## DEBUGGING CODE
  output Any pending_inputs;
  output Any msg_counter;

  output Any user_names;
  output Any user_ids;
  output Any user_rooms;
  output Any room_users;

  user_names = core_state.user_names;
  user_ids = core_state.user_ids;
  user_rooms = core_state.user_rooms;
  room_users = core_state.room_users;
}


chat_server_1.do(Connect msg)
{
  pending_inputs := update(pending_inputs, msg.channel, ());
}


chat_server_1.do(Disconnect msg)
{
  channel = msg.channel;
  pending_inputs := remove_key(pending_inputs, channel);
  is_logged_in = has_key(core_state.user_names, channel);
  core_state.do(logout(user: channel)) if is_logged_in;
}


chat_server_1.do(Received msg)
{
  channel = msg.channel;
  new_data = msg.data;
  pend_data = pending_inputs[channel];

  if new_data == ascii_newline:
    pending_inputs := update(pending_inputs, channel, ());
    maybe_msg = try_parse_msg(pending_inputs[channel], channel);
    if maybe_msg != nil:
      self.do(value(maybe_msg));
    else
      data_to_send := data_to_send & [msg_counter -> (channel, "ERROR syntax error")];
      msg_counter := msg_counter + 1;
    ;

  else
    pending_inputs := update(pending_inputs, channel, (pend_data | new_data));
  ;
}


chat_server_1.do(Sent msg)
{
  data_to_send := remove_key(data_to_send, msg.msg_id);
}

////////////////////////////////////////////////////////////////////////////////

chat_server_1.do(Login msg)
{
  user = msg.user;
  name = msg.name;

  check_res = core_state.login_check(user, name);

  core_state.do(msg) if check_res == :ok;

  resp_msg = match (check_res)
    ok                  = "OK",
    already_logged_in   = "ERROR already logged in",
    name_already_in_use = "ERROR name already in use";

  data_to_send := update(data_to_send, msg_counter, (user, resp_msg));
  msg_counter := msg_counter + 1;
}


chat_server_1.do(Logout msg)
{
  core_state.do(msg) if has_key(core_state.user_names, msg.user);
}


chat_server_1.do(JoinRoom msg)
{
  user = msg.user;

  check_res = core_state.join_room_check(user);

  core_state.do(msg) if check_res == :ok;

  resp_msg = if check_res == :ok then "OK" else "ERROR not logged in";

  data_to_send := update(data_to_send, msg_counter, (user, resp_msg));
  msg_counter  := msg_counter + 1;
}


chat_server_1.do(LeaveRoom msg)
{
  user = msg.user;
  room = msg.room;

  check_res = core_state.leave_room_check(user, room);

  core_state.do(msg) if check_res == :ok;

  resp_msg = match (check_res)
    ok              = "OK",
    not_logged_in   = "ERROR not logged in",
    not_in_room     = "ERROR never joined room";

  data_to_send := update(data_to_send, msg_counter, (user, resp_msg));
  msg_counter  := msg_counter + 1;
}


chat_server_1.do(SendMsgToUser msg)
{
  sender = msg.sender;
  receiver = msg.receiver;
  msg_text = msg.msg_text;

  check_res = core_state.action_check(msg);

  resp_msg = match (check_res)
    not_logged_in     = "ERROR not logged in",
    unknown_receiver  = "ERROR unknown user",
    ok                = "OK";

  new_data_to_send = [msg_counter -> (sender, resp_msg)];
  msgs_sent = 1;

  if check_res == :ok:
    fwd_msg = "GOTUSERMSG " & core_state.user_names[sender] & " " & msg_text;
    new_data_to_send = new_data_to_send & [msg_counter + msgs_sent -> (core_state.user_ids[receiver], fwd_msg)];
    msgs_sent = msgs_sent + 1;
  ;

  data_to_send := data_to_send & new_data_to_send;
  msg_counter := msg_counter + msgs_sent;
}


chat_server_1.do(SendMsgToRoom msg)
{
  sender = msg.sender;
  target = msg.target;
  msg_text = msg.msg_text;

  check_res = core_state.action_check(msg);

  resp_msg = match (check_res)
    not_logged_in     = "ERROR not logged in",
    not_in_room       = "ERROR never joined room",
    ok                = "OK";

  new_data_to_send = [msg_counter -> (sender, resp_msg)];
  msgs_sent = 1;

  if check_res == :ok:
    fwd_msg = "GOTROOMMSG " & core_state.user_names[sender] & " #" & target & " " & msg_text;
    receivers = rand_sort(lookup(core_state.room_users, target, []));
    new_data_to_send = new_data_to_send & merge(([msg_counter + i + 1 -> (r, fwd_msg)] : r @ i <- receivers));
    msgs_sent = msgs_sent + length(receivers);
  ;

  data_to_send := data_to_send & new_data_to_send;
  msg_counter := msg_counter + msgs_sent;
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

auto chat_server_1_wrapper
{
  discrete input ChatServerMsg message;

  output [Nat -> (Nat, String)] data_to_send;

  core_server = chat_server_1();

  core_server.do(message);

  data_to_send = core_server.data_to_send;

  //## DEBUGGING CODE
  output Any pending_inputs;
  output Any msg_counter;

  output Any user_names;
  output Any user_ids;
  output Any user_rooms;
  output Any room_users;

  pending_inputs = core_server.pending_inputs;
  msg_counter = core_server.msg_counter;

  user_names = core_server.user_names;
  user_ids = core_server.user_ids;
  user_rooms = core_server.user_rooms;
  room_users = core_server.room_users;
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

Bool RunAllChatServer1Tests()
{
  auto chat_server_1_wrapper cs;

  update cs;

  sorted_users = rand_sort(set((u : u, unused_var <- chat_server_test_data_1)));
  conn_ids = merge(([u -> i] : u @ i <- sorted_users));

  for i < size(conn_ids):
    cs.message = connect(i);
    update cs;
    // print cs;
  ;

  for u, s <- chat_server_test_data_1:
    cid = conn_ids[u];
    for ch <- raw_str(s):
      cs.message = received(cid, ch);
      update cs;
    ;
    cs.message = received(cid, ascii_newline);
    update cs;
    // print s;
    // print cs;
  ;

  for i < size(conn_ids):
    cs.message = disconnect(i);
    update cs;
    // print cs;
  ;

  if cs.data_to_send != chat_server_exp_res_1:
    Print("ERROR (1)\n");
    print cs.data_to_send;
    print chat_server_exp_res_1;
    return false;
  ;

  for i < cs.msg_counter:
    cs.message = sent(i);
    update cs;
    // print cs;
    if size(cs.data_to_send) != cs.msg_counter - i - 1:
      Print("ERROR (2)\n");
      print i;
      print cs.data_to_send;
      return false;
    ;
  ;

  assert cs.data_to_send == [:];
  return true;
}
